"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/helpers.ts
function getTokenFromOptionsOrEnv(options) {
  if (options == null ? void 0 : options.token) {
    return options.token;
  }
  if (process.env.BLOB_READ_WRITE_TOKEN) {
    return process.env.BLOB_READ_WRITE_TOKEN;
  }
  throw new BlobError(
    "No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls."
  );
}
var BlobError = class extends Error {
  constructor(message) {
    super(`Vercel Blob: ${message}`);
  }
};
var BlobAccessError = class extends BlobError {
  constructor() {
    super("Access denied, please provide a valid token for this resource");
  }
};
var BlobStoreNotFoundError = class extends BlobError {
  constructor() {
    super("This store does not exist");
  }
};
var BlobStoreSuspendedError = class extends BlobError {
  constructor() {
    super("This store has been suspended");
  }
};
var BlobUnknownError = class extends BlobError {
  constructor() {
    super("Unknown error, please visit https://vercel.com/help");
  }
};
var BlobNotFoundError = class extends BlobError {
  constructor() {
    super("The requested blob does not exist");
  }
};
async function validateBlobApiResponse(response) {
  var _a;
  if (!response.ok) {
    if (response.status >= 500) {
      throw new BlobUnknownError();
    } else {
      let data;
      try {
        data = await response.json();
      } catch (e) {
        throw new BlobUnknownError();
      }
      const error = data.error;
      switch (error == null ? void 0 : error.code) {
        case "store_suspended":
          throw new BlobStoreSuspendedError();
        case "forbidden":
          throw new BlobAccessError();
        case "not_found":
          throw new BlobNotFoundError();
        case "store_not_found":
          throw new BlobStoreNotFoundError();
        case "bad_request":
          throw new BlobError((_a = error.message) != null ? _a : "Bad request");
        case "unknown_error":
        case "not_allowed":
        default:
          throw new BlobUnknownError();
      }
    }
  }
}
var BLOB_API_VERSION = 5;
function getApiVersionHeader() {
  let versionOverride = null;
  try {
    versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;
  } catch (e2) {
  }
  return {
    "x-api-version": `${versionOverride != null ? versionOverride : BLOB_API_VERSION}`
  };
}
function getApiUrl(pathname = "") {
  let baseUrl = null;
  try {
    baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;
  } catch (e3) {
  }
  return `${baseUrl || "https://blob.vercel-storage.com"}${pathname}`;
}

// src/put.ts
var _undici = require('undici');
function createPutMethod({
  allowedOptions,
  getToken,
  extraChecks
}) {
  return async function put(pathname, body, options) {
    if (!pathname) {
      throw new BlobError("pathname is required");
    }
    if (!body) {
      throw new BlobError("body is required");
    }
    if (!options) {
      throw new BlobError("missing options, see usage");
    }
    if (options.access !== "public") {
      throw new BlobError('access must be "public"');
    }
    if (extraChecks) {
      extraChecks(options);
    }
    const token = getToken ? await getToken(pathname, options) : getTokenFromOptionsOrEnv(options);
    const headers = {
      ...getApiVersionHeader(),
      authorization: `Bearer ${token}`
    };
    if (allowedOptions.includes("contentType") && options.contentType) {
      headers["x-content-type"] = options.contentType;
    }
    if (allowedOptions.includes("addRandomSuffix") && options.addRandomSuffix !== void 0) {
      headers["x-add-random-suffix"] = options.addRandomSuffix ? "1" : "0";
    }
    if (allowedOptions.includes("cacheControlMaxAge") && options.cacheControlMaxAge !== void 0) {
      headers["x-cache-control-max-age"] = options.cacheControlMaxAge.toString();
    }
    const blobApiResponse = await _undici.fetch.call(void 0, getApiUrl(`/${pathname}`), {
      method: "PUT",
      body,
      headers,
      // required in order to stream some body types to Cloudflare
      // currently only supported in Node.js, we may have to feature detect this
      duplex: "half"
    });
    await validateBlobApiResponse(blobApiResponse);
    const blobResult = await blobApiResponse.json();
    return blobResult;
  };
}













exports.getTokenFromOptionsOrEnv = getTokenFromOptionsOrEnv; exports.BlobError = BlobError; exports.BlobAccessError = BlobAccessError; exports.BlobStoreNotFoundError = BlobStoreNotFoundError; exports.BlobStoreSuspendedError = BlobStoreSuspendedError; exports.BlobUnknownError = BlobUnknownError; exports.BlobNotFoundError = BlobNotFoundError; exports.validateBlobApiResponse = validateBlobApiResponse; exports.getApiVersionHeader = getApiVersionHeader; exports.getApiUrl = getApiUrl; exports.createPutMethod = createPutMethod;
//# sourceMappingURL=chunk-FSBJMJTU.cjs.map