{"version":3,"sources":["../src/del.ts","../src/head.ts","../src/list.ts","../src/copy.ts","../src/index.ts"],"sourcesContent":["import { fetch } from 'undici';\nimport type { BlobCommandOptions } from './helpers';\nimport {\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  validateBlobApiResponse,\n} from './helpers';\n\ntype DeleteBlobApiResponse = null;\n\n/**\n * Deletes one or multiple blobs from your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#delete-a-blob\n *\n * @param url - Blob url or array of blob urls that identify the blobs to be deleted. You can only delete blobs that are located in a store, that your 'BLOB_READ_WRITE_TOKEN' has access to.\n * @param options - Additional options for the request.\n */\nexport async function del(\n  url: string[] | string,\n  options?: BlobCommandOptions,\n): Promise<void> {\n  const blobApiResponse = await fetch(getApiUrl('/delete'), {\n    method: 'POST',\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] }),\n  });\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  (await blobApiResponse.json()) as DeleteBlobApiResponse;\n}\n","import { fetch } from 'undici';\nimport type { BlobCommandOptions } from './helpers';\nimport {\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  validateBlobApiResponse,\n} from './helpers';\n\nexport interface HeadBlobResult {\n  url: string;\n  size: number;\n  uploadedAt: Date;\n  pathname: string;\n  contentType: string;\n  contentDisposition: string;\n  cacheControl: string;\n}\n\ninterface HeadBlobApiResponse extends Omit<HeadBlobResult, 'uploadedAt'> {\n  uploadedAt: string; // when receiving data from our API, uploadedAt is a string\n}\n\n/**\n * Fetches metadata of a blob object.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#get-blob-metadata\n *\n * @param url - Blob url to lookup.\n * @param options - Additional options for the request.\n */\nexport async function head(\n  url: string,\n  options?: BlobCommandOptions,\n): Promise<HeadBlobResult> {\n  const headApiUrl = new URL(getApiUrl());\n  headApiUrl.searchParams.set('url', url);\n\n  const blobApiResponse = await fetch(headApiUrl, {\n    method: 'GET', // HEAD can't have body as a response, so we use GET\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n    },\n  });\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  const headResult = (await blobApiResponse.json()) as HeadBlobApiResponse;\n\n  return mapBlobResult(headResult);\n}\n\nfunction mapBlobResult(blobResult: HeadBlobApiResponse): HeadBlobResult;\n\nfunction mapBlobResult(blobResult: HeadBlobApiResponse): HeadBlobResult {\n  return {\n    ...blobResult,\n    uploadedAt: new Date(blobResult.uploadedAt),\n  };\n}\n","import { fetch } from 'undici';\nimport type { BlobCommandOptions } from './helpers';\nimport {\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  validateBlobApiResponse,\n} from './helpers';\n\nexport interface ListBlobResultBlob {\n  url: string;\n  pathname: string;\n  size: number;\n  uploadedAt: Date;\n}\n\nexport interface ListBlobResult {\n  blobs: ListBlobResultBlob[];\n  cursor?: string;\n  hasMore: boolean;\n}\n\nexport interface ListFoldedBlobResult extends ListBlobResult {\n  folders: string[];\n}\n\ninterface ListBlobApiResponseBlob\n  extends Omit<ListBlobResultBlob, 'uploadedAt'> {\n  uploadedAt: string;\n}\n\ninterface ListBlobApiResponse extends Omit<ListBlobResult, 'blobs'> {\n  blobs: ListBlobApiResponseBlob[];\n  folders?: string[];\n}\n\nexport interface ListCommandOptions<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n> extends BlobCommandOptions {\n  /**\n   * The maximum number of blobs to return.\n   * @defaultvalue 1000\n   */\n  limit?: number;\n  /**\n   * Filters the result to only include blobs that start with this prefix.\n   * If used together with `mode: 'folded'`, make sure to include a trailing slash after the foldername.\n   */\n  prefix?: string;\n  /**\n   * The cursor to use for pagination. Can be obtained from the response of a previous `list` request.\n   */\n  cursor?: string;\n  /**\n   * Defines how the blobs are listed\n   * - `expanded` the blobs property contains all blobs.\n   * - `folded` the blobs property contains only the blobs at the root level of your store. Blobs that are located inside a folder get merged into a single entry in the folder response property.\n   * @defaultvalue 'expanded'\n   */\n  mode?: M;\n}\n\ntype ListCommandResult<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n> = M extends 'folded' ? ListFoldedBlobResult : ListBlobResult;\n\n/**\n * Fetches a paginated list of blob objects from your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#list-blobs\n *\n * @param options - Additional options for the request.\n */\nexport async function list<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n>(options?: ListCommandOptions<M>): Promise<ListCommandResult<M>> {\n  const listApiUrl = new URL(getApiUrl());\n  if (options?.limit) {\n    listApiUrl.searchParams.set('limit', options.limit.toString());\n  }\n  if (options?.prefix) {\n    listApiUrl.searchParams.set('prefix', options.prefix);\n  }\n  if (options?.cursor) {\n    listApiUrl.searchParams.set('cursor', options.cursor);\n  }\n  if (options?.mode) {\n    listApiUrl.searchParams.set('mode', options.mode);\n  }\n\n  const blobApiResponse = await fetch(listApiUrl, {\n    method: 'GET',\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n    },\n  });\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  const results = (await blobApiResponse.json()) as ListBlobApiResponse;\n\n  if (options?.mode === 'folded') {\n    return {\n      folders: results.folders ?? [],\n      cursor: results.cursor,\n      hasMore: results.hasMore,\n      blobs: results.blobs.map(mapBlobResult),\n    } as ListCommandResult<M>;\n  }\n\n  return {\n    cursor: results.cursor,\n    hasMore: results.hasMore,\n    blobs: results.blobs.map(mapBlobResult),\n  } as ListCommandResult<M>;\n}\n\nfunction mapBlobResult(\n  blobResult: ListBlobApiResponseBlob,\n): ListBlobResultBlob {\n  return {\n    ...blobResult,\n    uploadedAt: new Date(blobResult.uploadedAt),\n  };\n}\n","import { fetch } from 'undici';\nimport type { CreateBlobCommandOptions } from './helpers';\nimport {\n  BlobError,\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  validateBlobApiResponse,\n} from './helpers';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface -- expose option interface for each API method for better extensibility in the future\nexport interface CopyCommandOptions extends CreateBlobCommandOptions {}\n\nexport interface CopyBlobResult {\n  url: string;\n  pathname: string;\n  contentType?: string;\n  contentDisposition: string;\n}\n\n/**\n * Copies a blob to another location in your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#copy-a-blob\n *\n * @param fromUrl - The blob URL to copy. You can only copy blobs that are in the store, that your 'BLOB_READ_WRITE_TOKEN' has access to.\n * @param toPathname - The pathname to copy the blob to. This includes the filename.\n * @param options - Additional options. The copy method will not preserve any metadata configuration (e.g.: 'cacheControlMaxAge') of the source blob. If you want to copy the metadata, you need to define it here again.\n */\nexport async function copy(\n  fromUrl: string,\n  toPathname: string,\n  options: CopyCommandOptions,\n): Promise<CopyBlobResult> {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (!options) {\n    throw new BlobError('missing options, see usage');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (options.access !== 'public') {\n    throw new BlobError('access must be \"public\"');\n  }\n\n  const headers: Record<string, string> = {\n    ...getApiVersionHeader(),\n    authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n  };\n\n  if (options.addRandomSuffix !== undefined) {\n    headers['x-add-random-suffix'] = options.addRandomSuffix ? '1' : '0';\n  }\n\n  if (options.contentType) {\n    headers['x-content-type'] = options.contentType;\n  }\n\n  if (options.cacheControlMaxAge !== undefined) {\n    headers['x-cache-control-max-age'] = options.cacheControlMaxAge.toString();\n  }\n\n  const blobApiResponse = await fetch(\n    getApiUrl(`/${toPathname}?fromUrl=${fromUrl}`),\n    { method: 'PUT', headers },\n  );\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  return (await blobApiResponse.json()) as CopyBlobResult;\n}\n","import type { PutCommandOptions } from './put';\nimport { createPutMethod } from './put';\n\n// expose the BlobError types\nexport {\n  BlobAccessError,\n  BlobError,\n  BlobNotFoundError,\n  BlobStoreNotFoundError,\n  BlobStoreSuspendedError,\n  BlobUnknownError,\n} from './helpers';\n\n// vercelBlob.put()\n\nexport type { PutBlobResult, PutCommandOptions } from './put';\n\n/**\n * Uploads a blob into your store from your server.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#upload-a-blob\n *\n * If you want to upload from the browser directly, check out the documentation for client uploads: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#client-uploads\n *\n * @param pathname - The pathname to upload the blob to. This includes the filename.\n * @param body - The contents of your blob. This has to be a supported fetch body type https://developer.mozilla.org/en-US/docs/Web/API/fetch#body.\n * @param options - Additional options like `token` or `contentType`.\n */\nexport const put = createPutMethod<PutCommandOptions>({\n  allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n});\n\n//  vercelBlob.del()\n\nexport { del } from './del';\n\n// vercelBlob.head()\n\nexport type { HeadBlobResult } from './head';\nexport { head } from './head';\n\n// vercelBlob.list()\n\nexport type {\n  ListBlobResultBlob,\n  ListBlobResult,\n  ListCommandOptions,\n  ListFoldedBlobResult,\n} from './list';\nexport { list } from './list';\n\n// vercelBlob.copy()\n\nexport type { CopyBlobResult, CopyCommandOptions } from './copy';\nexport { copy } from './copy';\n"],"mappings":";;;;;;;;;;;;;;;AAAA,SAAS,aAAa;AAkBtB,eAAsB,IACpB,KACA,SACe;AACf,QAAM,kBAAkB,MAAM,MAAM,UAAU,SAAS,GAAG;AAAA,IACxD,QAAQ;AAAA,IACR,SAAS;AAAA,MACP,GAAG,oBAAoB;AAAA,MACvB,eAAe,UAAU,yBAAyB,OAAO;AAAA,MACzD,gBAAgB;AAAA,IAClB;AAAA,IACA,MAAM,KAAK,UAAU,EAAE,MAAM,MAAM,QAAQ,GAAG,IAAI,MAAM,CAAC,GAAG,EAAE,CAAC;AAAA,EACjE,CAAC;AAED,QAAM,wBAAwB,eAAe;AAE7C,EAAC,MAAM,gBAAgB,KAAK;AAC9B;;;ACnCA,SAAS,SAAAA,cAAa;AA8BtB,eAAsB,KACpB,KACA,SACyB;AACzB,QAAM,aAAa,IAAI,IAAI,UAAU,CAAC;AACtC,aAAW,aAAa,IAAI,OAAO,GAAG;AAEtC,QAAM,kBAAkB,MAAMC,OAAM,YAAY;AAAA,IAC9C,QAAQ;AAAA;AAAA,IACR,SAAS;AAAA,MACP,GAAG,oBAAoB;AAAA,MACvB,eAAe,UAAU,yBAAyB,OAAO;AAAA,IAC3D;AAAA,EACF,CAAC;AAED,QAAM,wBAAwB,eAAe;AAE7C,QAAM,aAAc,MAAM,gBAAgB,KAAK;AAE/C,SAAO,cAAc,UAAU;AACjC;AAIA,SAAS,cAAc,YAAiD;AACtE,SAAO;AAAA,IACL,GAAG;AAAA,IACH,YAAY,IAAI,KAAK,WAAW,UAAU;AAAA,EAC5C;AACF;;;AC3DA,SAAS,SAAAC,cAAa;AAwEtB,eAAsB,KAEpB,SAAgE;AA1ElE;AA2EE,QAAM,aAAa,IAAI,IAAI,UAAU,CAAC;AACtC,MAAI,mCAAS,OAAO;AAClB,eAAW,aAAa,IAAI,SAAS,QAAQ,MAAM,SAAS,CAAC;AAAA,EAC/D;AACA,MAAI,mCAAS,QAAQ;AACnB,eAAW,aAAa,IAAI,UAAU,QAAQ,MAAM;AAAA,EACtD;AACA,MAAI,mCAAS,QAAQ;AACnB,eAAW,aAAa,IAAI,UAAU,QAAQ,MAAM;AAAA,EACtD;AACA,MAAI,mCAAS,MAAM;AACjB,eAAW,aAAa,IAAI,QAAQ,QAAQ,IAAI;AAAA,EAClD;AAEA,QAAM,kBAAkB,MAAMC,OAAM,YAAY;AAAA,IAC9C,QAAQ;AAAA,IACR,SAAS;AAAA,MACP,GAAG,oBAAoB;AAAA,MACvB,eAAe,UAAU,yBAAyB,OAAO;AAAA,IAC3D;AAAA,EACF,CAAC;AAED,QAAM,wBAAwB,eAAe;AAE7C,QAAM,UAAW,MAAM,gBAAgB,KAAK;AAE5C,OAAI,mCAAS,UAAS,UAAU;AAC9B,WAAO;AAAA,MACL,UAAS,aAAQ,YAAR,YAAmB,CAAC;AAAA,MAC7B,QAAQ,QAAQ;AAAA,MAChB,SAAS,QAAQ;AAAA,MACjB,OAAO,QAAQ,MAAM,IAAIC,cAAa;AAAA,IACxC;AAAA,EACF;AAEA,SAAO;AAAA,IACL,QAAQ,QAAQ;AAAA,IAChB,SAAS,QAAQ;AAAA,IACjB,OAAO,QAAQ,MAAM,IAAIA,cAAa;AAAA,EACxC;AACF;AAEA,SAASA,eACP,YACoB;AACpB,SAAO;AAAA,IACL,GAAG;AAAA,IACH,YAAY,IAAI,KAAK,WAAW,UAAU;AAAA,EAC5C;AACF;;;AC5HA,SAAS,SAAAC,cAAa;AA4BtB,eAAsB,KACpB,SACA,YACA,SACyB;AAEzB,MAAI,CAAC,SAAS;AACZ,UAAM,IAAI,UAAU,4BAA4B;AAAA,EAClD;AAGA,MAAI,QAAQ,WAAW,UAAU;AAC/B,UAAM,IAAI,UAAU,yBAAyB;AAAA,EAC/C;AAEA,QAAM,UAAkC;AAAA,IACtC,GAAG,oBAAoB;AAAA,IACvB,eAAe,UAAU,yBAAyB,OAAO;AAAA,EAC3D;AAEA,MAAI,QAAQ,oBAAoB,QAAW;AACzC,YAAQ,qBAAqB,IAAI,QAAQ,kBAAkB,MAAM;AAAA,EACnE;AAEA,MAAI,QAAQ,aAAa;AACvB,YAAQ,gBAAgB,IAAI,QAAQ;AAAA,EACtC;AAEA,MAAI,QAAQ,uBAAuB,QAAW;AAC5C,YAAQ,yBAAyB,IAAI,QAAQ,mBAAmB,SAAS;AAAA,EAC3E;AAEA,QAAM,kBAAkB,MAAMC;AAAA,IAC5B,UAAU,IAAI,sBAAsB,SAAS;AAAA,IAC7C,EAAE,QAAQ,OAAO,QAAQ;AAAA,EAC3B;AAEA,QAAM,wBAAwB,eAAe;AAE7C,SAAQ,MAAM,gBAAgB,KAAK;AACrC;;;ACzCO,IAAM,MAAM,gBAAmC;AAAA,EACpD,gBAAgB,CAAC,sBAAsB,mBAAmB,aAAa;AACzE,CAAC;","names":["fetch","fetch","fetch","fetch","mapBlobResult","fetch","fetch"]}