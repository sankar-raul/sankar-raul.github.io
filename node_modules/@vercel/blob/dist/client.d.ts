import * as stream from 'stream';
import { IncomingMessage } from 'node:http';
import { a as PutBlobResult, B as BlobCommandOptions } from './put-96a1f07e.js';

interface ClientPutCommandOptions {
    access: 'public';
    token: string;
    contentType?: string;
}
declare const put: (pathname: string, body: string | stream.Readable | Blob | ArrayBuffer | FormData | ReadableStream<any> | File, options?: ClientPutCommandOptions | undefined) => Promise<PutBlobResult>;
interface UploadOptions {
    /**
     * Whether the blob should be publicly accessible. Support for private blobs is planned.
     */
    access: 'public';
    /**
     * Defines the content type of the blob. By default, this value is inferred from the pathname. Sent as the 'content-type' header when downloading a blob.
     */
    contentType?: string;
    /**
     * A route that implements the `handleUpload` function for generating a client token.
     */
    handleUploadUrl: string;
    /**
     * Additional data which will be sent to your `handleUpload` route.
     */
    clientPayload?: string;
}
/**
 * Uploads a blob into your store from the client.
 * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#client-uploads
 *
 * If you want to upload from your server instead, check out the documentation for the put operation: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#upload-a-blob
 *
 * @param pathname - The pathname to upload the blob to. This includes the filename.
 * @param body - The contents of your blob. This has to be a supported fetch body type https://developer.mozilla.org/en-US/docs/Web/API/fetch#body.
 * @param options - Additional options.
 */
declare const upload: (pathname: string, body: string | stream.Readable | Blob | ArrayBuffer | FormData | ReadableStream<any> | File, options?: UploadOptions | undefined) => Promise<PutBlobResult>;
type DecodedClientTokenPayload = Omit<GenerateClientTokenOptions, 'token'> & {
    validUntil: number;
};
declare function getPayloadFromClientToken(clientToken: string): DecodedClientTokenPayload;
declare const EventTypes: {
    readonly generateClientToken: "blob.generate-client-token";
    readonly uploadCompleted: "blob.upload-completed";
};
interface GenerateClientTokenEvent {
    type: (typeof EventTypes)['generateClientToken'];
    payload: {
        pathname: string;
        callbackUrl: string;
        clientPayload?: string;
    };
}
interface UploadCompletedEvent {
    type: (typeof EventTypes)['uploadCompleted'];
    payload: {
        blob: PutBlobResult;
        tokenPayload?: string;
    };
}
type HandleUploadBody = GenerateClientTokenEvent | UploadCompletedEvent;
type RequestType = IncomingMessage | Request;
interface HandleUploadOptions {
    body: HandleUploadBody;
    onBeforeGenerateToken: (pathname: string, clientPayload?: string) => Promise<Pick<GenerateClientTokenOptions, 'allowedContentTypes' | 'maximumSizeInBytes' | 'validUntil' | 'addRandomSuffix' | 'cacheControlMaxAge'> & {
        tokenPayload?: string;
    }>;
    onUploadCompleted: (body: UploadCompletedEvent['payload']) => Promise<void>;
    token?: string;
    request: RequestType;
}
declare function handleUpload({ token, request, body, onBeforeGenerateToken, onUploadCompleted, }: HandleUploadOptions): Promise<{
    type: GenerateClientTokenEvent['type'];
    clientToken: string;
} | {
    type: UploadCompletedEvent['type'];
    response: 'ok';
}>;
declare function generateClientTokenFromReadWriteToken({ token, ...argsWithoutToken }: GenerateClientTokenOptions): Promise<string>;
interface GenerateClientTokenOptions extends BlobCommandOptions {
    pathname: string;
    onUploadCompleted?: {
        callbackUrl: string;
        tokenPayload?: string;
    };
    maximumSizeInBytes?: number;
    allowedContentTypes?: string[];
    validUntil?: number;
    addRandomSuffix?: boolean;
    cacheControlMaxAge?: number;
}

export { ClientPutCommandOptions, DecodedClientTokenPayload, GenerateClientTokenOptions, HandleUploadBody, HandleUploadOptions, UploadOptions, generateClientTokenFromReadWriteToken, getPayloadFromClientToken, handleUpload, put, upload };
